import * as easingPatterns from './easing-patterns';
import { getContainer, getOffset } from './util';
import Vue from 'vue';
export default function goTo(_target, _settings = {}) {
    const settings = {
        container: document.scrollingElement || document.body || document.documentElement,
        duration: 500,
        offset: 0,
        easing: 'easeInOutCubic',
        appOffset: true,
        ..._settings
    };
    const container = getContainer(settings.container);
    if (settings.appOffset) {
        const isDrawer = container.classList.contains('v-navigation-drawer');
        const isClipped = container.classList.contains('v-navigation-drawer--clipped');
        settings.offset += Vue.prototype.$vuetify.application.bar;
        if (!isDrawer || isClipped)
            settings.offset += Vue.prototype.$vuetify.application.top;
    }
    const startTime = performance.now();
    const targetLocation = getOffset(_target) - settings.offset;
    const startLocation = container.scrollTop;
    if (targetLocation === startLocation)
        return Promise.resolve(targetLocation);
    const ease = typeof settings.easing === 'function'
        ? settings.easing
        : easingPatterns[settings.easing];
    if (!ease)
        throw new TypeError(`Easing function "${settings.easing}" not found.`);
    // tslint:disable-next-line:promise-must-complete
    return new Promise(resolve => requestAnimationFrame(function step(currentTime) {
        const timeElapsed = currentTime - startTime;
        const progress = Math.abs(settings.duration ? Math.min(timeElapsed / settings.duration, 1) : 1);
        container.scrollTop = Math.floor(startLocation + (targetLocation - startLocation) * ease(progress));
        if (progress === 1 || container.clientHeight + container.scrollTop === container.scrollHeight) {
            return resolve(targetLocation);
        }
        requestAnimationFrame(step);
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcG9uZW50cy9WdWV0aWZ5L2dvVG8vaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxLQUFLLGNBQWMsTUFBTSxtQkFBbUIsQ0FBQTtBQUNuRCxPQUFPLEVBQ0wsWUFBWSxFQUNaLFNBQVMsRUFDVixNQUFNLFFBQVEsQ0FBQTtBQUNmLE9BQU8sR0FBRyxNQUFNLEtBQUssQ0FBQTtBQVdyQixNQUFNLENBQUMsT0FBTyxVQUFVLElBQUksQ0FBRSxPQUFtQixFQUFFLFlBQW1DLEVBQUU7SUFDdEYsTUFBTSxRQUFRLEdBQWlCO1FBQzdCLFNBQVMsRUFBRyxRQUFRLENBQUMsZ0JBQXVDLElBQUksUUFBUSxDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsZUFBZTtRQUN6RyxRQUFRLEVBQUUsR0FBRztRQUNiLE1BQU0sRUFBRSxDQUFDO1FBQ1QsTUFBTSxFQUFFLGdCQUFnQjtRQUN4QixTQUFTLEVBQUUsSUFBSTtRQUNmLEdBQUcsU0FBUztLQUNiLENBQUE7SUFDRCxNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFBO0lBRWxELElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRTtRQUN0QixNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBO1FBQ3BFLE1BQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLDhCQUE4QixDQUFDLENBQUE7UUFFOUUsUUFBUSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFBO1FBQ3pELElBQUksQ0FBQyxRQUFRLElBQUksU0FBUztZQUFFLFFBQVEsQ0FBQyxNQUFNLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQTtLQUN0RjtJQUVELE1BQU0sU0FBUyxHQUFHLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQTtJQUNuQyxNQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQTtJQUMzRCxNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFBO0lBQ3pDLElBQUksY0FBYyxLQUFLLGFBQWE7UUFBRSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUE7SUFFNUUsTUFBTSxJQUFJLEdBQUcsT0FBTyxRQUFRLENBQUMsTUFBTSxLQUFLLFVBQVU7UUFDaEQsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNO1FBQ2pCLENBQUMsQ0FBRSxjQUE0RCxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUNsRixJQUFJLENBQUMsSUFBSTtRQUFFLE1BQU0sSUFBSSxTQUFTLENBQUMsb0JBQW9CLFFBQVEsQ0FBQyxNQUFNLGNBQWMsQ0FBQyxDQUFBO0lBRWpGLGlEQUFpRDtJQUNqRCxPQUFPLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMscUJBQXFCLENBQUMsU0FBUyxJQUFJLENBQUUsV0FBbUI7UUFDcEYsTUFBTSxXQUFXLEdBQUcsV0FBVyxHQUFHLFNBQVMsQ0FBQTtRQUMzQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBRS9GLFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLEdBQUcsQ0FBQyxjQUFjLEdBQUcsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUE7UUFFbkcsSUFBSSxRQUFRLEtBQUssQ0FBQyxJQUFJLFNBQVMsQ0FBQyxZQUFZLEdBQUcsU0FBUyxDQUFDLFNBQVMsS0FBSyxTQUFTLENBQUMsWUFBWSxFQUFFO1lBQzdGLE9BQU8sT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFBO1NBQy9CO1FBRUQscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDN0IsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBlYXNpbmdQYXR0ZXJucyBmcm9tICcuL2Vhc2luZy1wYXR0ZXJucydcclxuaW1wb3J0IHtcclxuICBnZXRDb250YWluZXIsXHJcbiAgZ2V0T2Zmc2V0XHJcbn0gZnJvbSAnLi91dGlsJ1xyXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuXHJcbnR5cGUgR29Ub1RhcmdldCA9IG51bWJlciB8IHN0cmluZyB8IEhUTUxFbGVtZW50IHwgVnVlXHJcbmludGVyZmFjZSBHb1RvU2V0dGluZ3Mge1xyXG4gIGNvbnRhaW5lcjogc3RyaW5nIHwgSFRNTEVsZW1lbnQgfCBWdWVcclxuICBkdXJhdGlvbjogbnVtYmVyXHJcbiAgb2Zmc2V0OiBudW1iZXJcclxuICBlYXNpbmc6IHN0cmluZyB8IGVhc2luZ1BhdHRlcm5zLkVhc2luZ0Z1bmN0aW9uXHJcbiAgYXBwT2Zmc2V0OiBib29sZWFuXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdvVG8gKF90YXJnZXQ6IEdvVG9UYXJnZXQsIF9zZXR0aW5nczogUGFydGlhbDxHb1RvU2V0dGluZ3M+ID0ge30pOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIGNvbnN0IHNldHRpbmdzOiBHb1RvU2V0dGluZ3MgPSB7XHJcbiAgICBjb250YWluZXI6IChkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgbnVsbCkgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcbiAgICBkdXJhdGlvbjogNTAwLFxyXG4gICAgb2Zmc2V0OiAwLFxyXG4gICAgZWFzaW5nOiAnZWFzZUluT3V0Q3ViaWMnLFxyXG4gICAgYXBwT2Zmc2V0OiB0cnVlLFxyXG4gICAgLi4uX3NldHRpbmdzXHJcbiAgfVxyXG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcihzZXR0aW5ncy5jb250YWluZXIpXHJcblxyXG4gIGlmIChzZXR0aW5ncy5hcHBPZmZzZXQpIHtcclxuICAgIGNvbnN0IGlzRHJhd2VyID0gY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucygndi1uYXZpZ2F0aW9uLWRyYXdlcicpXHJcbiAgICBjb25zdCBpc0NsaXBwZWQgPSBjb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCd2LW5hdmlnYXRpb24tZHJhd2VyLS1jbGlwcGVkJylcclxuXHJcbiAgICBzZXR0aW5ncy5vZmZzZXQgKz0gVnVlLnByb3RvdHlwZS4kdnVldGlmeS5hcHBsaWNhdGlvbi5iYXJcclxuICAgIGlmICghaXNEcmF3ZXIgfHwgaXNDbGlwcGVkKSBzZXR0aW5ncy5vZmZzZXQgKz0gVnVlLnByb3RvdHlwZS4kdnVldGlmeS5hcHBsaWNhdGlvbi50b3BcclxuICB9XHJcblxyXG4gIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpXHJcbiAgY29uc3QgdGFyZ2V0TG9jYXRpb24gPSBnZXRPZmZzZXQoX3RhcmdldCkgLSBzZXR0aW5ncy5vZmZzZXRcclxuICBjb25zdCBzdGFydExvY2F0aW9uID0gY29udGFpbmVyLnNjcm9sbFRvcFxyXG4gIGlmICh0YXJnZXRMb2NhdGlvbiA9PT0gc3RhcnRMb2NhdGlvbikgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0YXJnZXRMb2NhdGlvbilcclxuXHJcbiAgY29uc3QgZWFzZSA9IHR5cGVvZiBzZXR0aW5ncy5lYXNpbmcgPT09ICdmdW5jdGlvbidcclxuICAgID8gc2V0dGluZ3MuZWFzaW5nXHJcbiAgICA6IChlYXNpbmdQYXR0ZXJucyBhcyBEaWN0aW9uYXJ5PGVhc2luZ1BhdHRlcm5zLkVhc2luZ0Z1bmN0aW9uPilbc2V0dGluZ3MuZWFzaW5nXVxyXG4gIGlmICghZWFzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgRWFzaW5nIGZ1bmN0aW9uIFwiJHtzZXR0aW5ncy5lYXNpbmd9XCIgbm90IGZvdW5kLmApXHJcblxyXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpwcm9taXNlLW11c3QtY29tcGxldGVcclxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gc3RlcCAoY3VycmVudFRpbWU6IG51bWJlcikge1xyXG4gICAgY29uc3QgdGltZUVsYXBzZWQgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZVxyXG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLmFicyhzZXR0aW5ncy5kdXJhdGlvbiA/IE1hdGgubWluKHRpbWVFbGFwc2VkIC8gc2V0dGluZ3MuZHVyYXRpb24sIDEpIDogMSlcclxuXHJcbiAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gTWF0aC5mbG9vcihzdGFydExvY2F0aW9uICsgKHRhcmdldExvY2F0aW9uIC0gc3RhcnRMb2NhdGlvbikgKiBlYXNlKHByb2dyZXNzKSlcclxuXHJcbiAgICBpZiAocHJvZ3Jlc3MgPT09IDEgfHwgY29udGFpbmVyLmNsaWVudEhlaWdodCArIGNvbnRhaW5lci5zY3JvbGxUb3AgPT09IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIHJlc29sdmUodGFyZ2V0TG9jYXRpb24pXHJcbiAgICB9XHJcblxyXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApXHJcbiAgfSkpXHJcbn1cclxuIl19