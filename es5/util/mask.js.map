{"version":3,"sources":["../../src/util/mask.ts"],"names":[],"mappings":"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","sourcesContent":["export interface MaskItem {\r\n  test: (char: string) => boolean\r\n  convert?: (char: string) => string\r\n}\r\nexport type MaskType = '#' | 'A' | 'a' | 'N' | 'n' | 'X'\r\n\r\nexport const defaultDelimiters = /[-!$%^&*()_+|~=`{}[\\]:\";'<>?,./\\\\ ]/\r\n\r\nexport const isMaskDelimiter = (char: string): boolean => char ? defaultDelimiters.test(char) : false\r\n\r\nconst allowedMasks: Dictionary<MaskItem> = {\r\n  '#': {\r\n    test: char => /[0-9]/.test(char)\r\n  },\r\n  'A': {\r\n    test: char => /[A-Z]/i.test(char),\r\n    convert: char => char.toUpperCase()\r\n  },\r\n  'a': {\r\n    test: char => /[a-z]/i.test(char),\r\n    convert: char => char.toLowerCase()\r\n  },\r\n  'N': {\r\n    test: char => /[0-9A-Z]/i.test(char),\r\n    convert: char => char.toUpperCase()\r\n  },\r\n  'n': {\r\n    test: char => /[0-9a-z]/i.test(char),\r\n    convert: char => char.toLowerCase()\r\n  },\r\n  'X': {\r\n    test: isMaskDelimiter\r\n  }\r\n}\r\n\r\nconst isMask = (char: string): boolean => allowedMasks.hasOwnProperty(char)\r\n\r\nconst convert = (mask: MaskType, char: string): string => {\r\n  return allowedMasks[mask].convert ? allowedMasks[mask].convert!(char) : char\r\n}\r\n\r\nconst maskValidates = (mask: MaskType, char: string): boolean => {\r\n  if (char == null || !isMask(mask)) return false\r\n  return allowedMasks[mask].test(char)\r\n}\r\n\r\nexport const maskText = (text: string | null | undefined, masked: string | string[], dontFillMaskBlanks: boolean): string => {\r\n  if (text == null) return ''\r\n  text = String(text)\r\n  if (!masked.length || !text.length) return text\r\n  if (!Array.isArray(masked)) masked = masked.split('')\r\n\r\n  let textIndex = 0\r\n  let maskIndex = 0\r\n  let newText = ''\r\n\r\n  while (maskIndex < masked.length) {\r\n    const mask = masked[maskIndex]\r\n\r\n    // Assign the next character\r\n    const char = text[textIndex]\r\n\r\n    // Check if mask is delimiter\r\n    // and current char matches\r\n    if (!isMask(mask) && char === mask) {\r\n      newText += mask\r\n      textIndex++\r\n    // Check if not mask\r\n    } else if (!isMask(mask) && !dontFillMaskBlanks) {\r\n      newText += mask\r\n    // Check if is mask and validates\r\n    } else if (maskValidates(mask as MaskType, char)) {\r\n      newText += convert(mask as MaskType, char)\r\n      textIndex++\r\n    } else {\r\n      return newText\r\n    }\r\n\r\n    maskIndex++\r\n  }\r\n\r\n  return newText\r\n}\r\n\r\nexport const unmaskText = (text: string): string => {\r\n  return text ? String(text).replace(new RegExp(defaultDelimiters, 'g'), '') : text\r\n}\r\n"],"sourceRoot":""}