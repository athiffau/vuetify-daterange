{"version":3,"sources":["../../src/mixins/maskable.js"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Maskable\r\n *\r\n * @mixin\r\n *\r\n * Creates an input mask that is\r\n * generated from a masked str\r\n *\r\n * Example: mask=\"#### #### #### ####\"\r\n */\r\n\r\nimport {\r\n  isMaskDelimiter,\r\n  maskText,\r\n  unmaskText\r\n} from '../util/mask'\r\n\r\n/* @vue/component */\r\nexport default {\r\n  name: 'maskable',\r\n\r\n  props: {\r\n    dontFillMaskBlanks: Boolean,\r\n    mask: {\r\n      type: [Object, String],\r\n      default: null\r\n    },\r\n    returnMaskedValue: Boolean,\r\n    value: { required: false }\r\n  },\r\n\r\n  data: vm => ({\r\n    selection: 0,\r\n    lazySelection: 0,\r\n    lazyValue: vm.value,\r\n    preDefined: {\r\n      'credit-card': '#### - #### - #### - ####',\r\n      'date': '##/##/####',\r\n      'date-with-time': '##/##/#### ##:##',\r\n      'phone': '(###) ### - ####',\r\n      'social': '###-##-####',\r\n      'time': '##:##',\r\n      'time-with-seconds': '##:##:##'\r\n    }\r\n  }),\r\n\r\n  computed: {\r\n    masked () {\r\n      const preDefined = this.preDefined[this.mask]\r\n      const mask = preDefined || this.mask || ''\r\n\r\n      return mask.split('')\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    /**\r\n     * Make sure the cursor is in the correct\r\n     * location when the mask changes\r\n     */\r\n    mask () {\r\n      if (!this.$refs.input) return\r\n\r\n      const oldValue = this.$refs.input.value\r\n      const newValue = this.maskText(unmaskText(this.lazyValue))\r\n      let position = 0\r\n      let selection = this.selection\r\n\r\n      for (let index = 0; index < selection; index++) {\r\n        isMaskDelimiter(oldValue[index]) || position++\r\n      }\r\n\r\n      selection = 0\r\n      if (newValue) {\r\n        for (let index = 0; index < newValue.length; index++) {\r\n          isMaskDelimiter(newValue[index]) || position--\r\n          selection++\r\n          if (position <= 0) break\r\n        }\r\n      }\r\n\r\n      this.$nextTick(() => {\r\n        this.$refs.input.value = newValue\r\n        this.setCaretPosition(selection)\r\n      })\r\n    }\r\n  },\r\n\r\n  beforeMount () {\r\n    if (!this.mask ||\r\n      this.value == null ||\r\n      !this.returnMaskedValue\r\n    ) return\r\n\r\n    const value = this.maskText(this.value)\r\n\r\n    // See if masked value does not\r\n    // match the user given value\r\n    if (value === this.value) return\r\n\r\n    this.$emit('input', value)\r\n  },\r\n\r\n  methods: {\r\n    setCaretPosition (selection) {\r\n      this.selection = selection\r\n      window.setTimeout(() => {\r\n        this.$refs.input && this.$refs.input.setSelectionRange(this.selection, this.selection)\r\n      }, 0)\r\n    },\r\n    updateRange () {\r\n      /* istanbul ignore next */\r\n      if (!this.$refs.input) return\r\n\r\n      const newValue = this.maskText(this.lazyValue)\r\n      let selection = 0\r\n\r\n      this.$refs.input.value = newValue\r\n      if (newValue) {\r\n        for (let index = 0; index < newValue.length; index++) {\r\n          if (this.lazySelection <= 0) break\r\n          isMaskDelimiter(newValue[index]) || this.lazySelection--\r\n          selection++\r\n        }\r\n      }\r\n\r\n      this.setCaretPosition(selection)\r\n      // this.$emit() must occur only when all internal values are correct\r\n      this.$emit('input', this.returnMaskedValue ? this.$refs.input.value : this.lazyValue)\r\n    },\r\n    maskText (text) {\r\n      return this.mask ? maskText(text, this.masked, this.dontFillMaskBlanks) : text\r\n    },\r\n    unmaskText (text) {\r\n      return this.mask && !this.returnMaskedValue ? unmaskText(text) : text\r\n    },\r\n    // When the input changes and is\r\n    // re-created, ensure that the\r\n    // caret location is correct\r\n    setSelectionRange () {\r\n      this.$nextTick(this.updateRange)\r\n    },\r\n    resetSelections (input) {\r\n      if (!input.selectionEnd) return\r\n      this.selection = input.selectionEnd\r\n      this.lazySelection = 0\r\n\r\n      for (let index = 0; index < this.selection; index++) {\r\n        isMaskDelimiter(input.value[index]) || this.lazySelection++\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"sourceRoot":""}